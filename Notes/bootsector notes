
;*************************************
;FAT stuff
;*************************************

-ROOT ENTRY STUFF-

5354 4147 4532 2020 5359 5320 008a 044c
fd52 fd52 0000 044c fd52 0200 4100 0000

the 0200 part is the starting cluster because we start counting the first byte as 0. I think this value is stored as a little endian so its actually 2. 2 points to the 2nd entry in the FAT (first two are reserved for some reason), and it also points to the first cluster in the data region. the 2nd entry in the FAT is fff which is the EOC (marks end of file), so we dont need to load any more clusters. this will change tho, because our 2nd stage bootloader will get bigger, meaning our FAT entry will point to more clusters that contain our 2nd stage.

;*************************************
;LBA and CHS stuff
;*************************************

Im going to relate the CHS addressing scheme to HMS (hours, minutes, seconds), so 24:60:60 is our disk geometry. 

first off, 

1 mod 10 = 1
2 mod 10 = 2
3 mod 10 = 3
...
11 mod 10 = 1
12 mod 10 = 2
13 mod 10 = 3
...

so, now that we know the modulo operater can be used for raparounds, 
lets get back to LBA and CHS conversions. 

lets say we have 3h,41m,26s (a CHS of 3,41,26). lets try and convert this to seconds (LBA).

3 * 60 * 60 = 10,800 <-- the amount of seconds in 3 hours
41 * 60 = 2,460 <-- the amount of seconds in 41 mins
26 = 26 <-- the last 26 seconds of our time (3,41,26)

now we add all these values to get the amount of seconds in 3hours, 41mins, 26secs. 
10,800 + 2,460 + 26 = 13,286 seconds (this is our LBA)

converting 13,286 seconds (our LBA) back to HMS (CHS)

to get the amount of seconds (3hours, 41mins, 26secs <--this) from 13,286 seconds, all we need to do is 13,286 mod 60. this is the same raparound logic as the mod 10 examples I showed above.

S = 13,286(LBA) mod 60(SPT) = 26

to get the amount of minutes (3hours, 41mins <-- this, 26secs) from 13,286 seconds, we need to do 13,286sec / 60 to convert 13,286 seconds to minutes. then we just do mod 60 so we get the mins. its the same principal as the seconds conversion, but we are just doing it with minutes.

M = (13,286(LBA) / 60(SPT)) mod 60(HPC) = 41

to get the hours from 13,286, all we have to do is divide it by sixty to convert 13,286 seconds to get 221 minutes. then we have to devide 221 by 60 because there are 60 minutes in an hour. so we end up getting 3. 

H = 13,286(LBA) / (60(HPC) * 60(SPT)) = 3

keep in mind all these answers are floored. Also, to avoind confusion, I specificly left out the - 1 on the sector conversion because it doesn't really relate to this time analogy. Becuase LBA starts counting from 0, and CHS doesn't, we have to subtract 1 from the sector equation. So the reall sector equation would look more like this,

S = (LBA mod SPT) - 1

the reason we only need to do it with the S equation is because it comes out whole in all the other ones. try if u dont beleive me, u wont. it just has to do with rounding.

LBA	=	(cluster - 2 ) * sectors per cluster

this equation i think is referring to the fact that the first 2 entries in the FAT are reserved. cluster is equal to the cluster we want to read data (in data region). 

;*************************************
;FAT ENTRYS stuff
;*************************************


10011011 10110011 10011011 10110011	10011011 10110011 10011011 10110011	
|     0     ||     1     | |     2     ||     3     | |     4     |

the reason we devide the cluster by 2, then add it with itself is because if we get say cluster 4, we dont load the fourth byte. instead we start loading from the (4/2 = 2, 2+4=6) 6th byte. this is essentially the same as multiplying by 3/2, which is the fat entry to byte ratio (12/8 = 3/2). since each FAT entry is 3/2 or 1.5 times bigger than a byte, all we got to do is multiply the cluster num by 1.5 to access the byte we start refrencing from.

;*************************************
;GDT
;*************************************

We are not yet in full protected mode! Section 10.3 of the INTEL
80386 PROGRAMMER'S REFERENCE MANUAL 1986 states:

Immediately after setting the PE flag, the initialization code must flush
the processor's instruction prefetch queue by executing a JMP instruction.
The 80386 fetches and decodes instructions and addresses before they are
used; however, after a change into protected mode, the prefetched
instruction information (which pertains to real-address mode) is no longer
valid. A JMP forces the processor to discard the invalid information.

It isn't really necessary to do the JMP right away, as this implies.
It simply means that protected mode doesn't "kick in" until the segment
registers are reloaded. Above, we set the ES segment register to 0xB800.
This is the real-mode segment of the text video memory. With the PE bit
still set, let's copy a message from the real-mode data segment (DS) to
the video memory (ES).


The code above won't work in protected mode. It's there just to
prove that setting the PE bit is not enough to enter protected mode.

Now do a far jump. This reloads the CS register and flushes the
real-mode instructions from the prefetch queue. CS is the segment
register used for instruction fetches, so this is where the switch
from 16-bit instructions (real-mode) to 32-bit instructions
(protected-mode) takes place.

But what goes into CS? In real mode, we use the segment address. In
protected mode, we use a SELECTOR:

MSB  b14  b13  b12  b11  b10   b9   b8   b7   b6   b5   b4   b3   b2   b1   LSB
;+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
;|                                index                           | L  |   RPL   |
;+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

index is a 13-bit index into the GDT. It selects one of the possible 8192
descriptors in the table. (Note: 8192 descriptors/table, 8 bytes/descriptor.
The GDT is no larger than 64K.)


